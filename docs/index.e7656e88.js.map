{"mappings":"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","sources":["../../../../usr/lib/node_modules/parcel/node_modules/@parcel/runtime-browser-hmr/lib/HMRRuntime.js","../camus3/src/main.ts","../camus3/src/AST.ts","../../../../usr/lib/node_modules/parcel/node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","../camus3/src/Parser.ts","../camus3/src/Assert.ts","../camus3/src/Renderer.ts","../camus3/src/PrettyPrinter.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst HMR_RUNTIME = _fs().default.readFileSync(_path().default.join(__dirname, './loaders/hmr-runtime.js'), 'utf8');\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    options\n  }) {\n    if (bundle.type !== 'js' || !options.hmrOptions) {\n      return;\n    }\n\n    const {\n      host,\n      port\n    } = options.hmrOptions;\n    return {\n      filePath: __filename,\n      code: `var HMR_HOST = ${JSON.stringify(host != null ? host : null)};` + `var HMR_PORT = ${JSON.stringify(port != null ? port : null)};` + `var HMR_SECURE = ${JSON.stringify(!!(options.serveOptions && options.serveOptions.https))};` + `var HMR_ENV_HASH = \"${(0, _utils().md5FromObject)(bundle.env)}\";` + `module.bundle.HMR_BUNDLE_ID = ${JSON.stringify(bundle.id)};` + HMR_RUNTIME,\n      isEntry: true\n    };\n  }\n\n});\n\nexports.default = _default;","export * as AST from './AST';\nexport * as Parser from './Parser';\nexport * as Renderer from './Renderer';\n","type Position = {\n    line: number,\n    col: number,\n};\n\ntype Range = {\n    start?: Position,\n    end?: Position,\n};\n\nexport enum CamusNodeType {\n    Heading = 1,\n    Block,\n    InlineStyle,\n    InlineCode,\n    InlineIgnore,\n    Link,\n    Ref,\n    FootnoteRef,\n    FootnoteText,\n    FootnoteBlock,\n    Image,\n    List,\n    ListItem,\n    HorizontalRule,\n}\n\nexport type HeadingNode = Range & {\n    _nodeType: CamusNodeType.Heading,\n    level: number,\n    text: CamusLine\n};\n\n// NOTE: type='verbatim' and type='code' will have CamusLine that only contains strings.\nexport type BlockNode = Range & {\n    _nodeType: CamusNodeType.Block,\n    type: string,\n    arg: string,\n    text: CamusLogicLine[],\n};\n\nexport type InlineStyleNode = Range & {\n    _nodeType: CamusNodeType.InlineStyle,\n    style: ('bold'|'italics'|'underline'|'delete')[],\n    text: CamusLine,\n}\n\nexport type InlineCodeNode = Range & {\n    _nodeType: CamusNodeType.InlineCode,\n    text: string,\n};\n\nexport type InlineIgnoreNode = Range & {\n    _nodeType: CamusNodeType.InlineIgnore,\n    text: string,\n}\n\nexport type LinkNode = Range & {\n    _nodeType: CamusNodeType.Link,\n    url: string,\n    text: string,\n};\n\nexport type RefNode = Range & {\n    _nodeType: CamusNodeType.Ref,\n    path: string,\n};\n\nexport type FootnoteRefNode = Range & {\n    _nodeType: CamusNodeType.FootnoteRef,\n    id: string,\n};\nexport type FootnoteTextNode = Range & {\n    _nodeType: CamusNodeType.FootnoteText,\n    id: string,\n    text: CamusLogicLine[],\n};\nexport type FootnoteBlockNode = Range & {\n    _nodeType: CamusNodeType.FootnoteBlock,\n    content: FootnoteTextNode[],\n}\nexport type ImageNode = Range & {\n    _nodeType: CamusNodeType.Image,\n    url: string,\n    alt: string,\n};\n\nexport type ListNode = Range & {\n    _nodeType: CamusNodeType.List,\n    ordered: boolean,\n    items: ListItemNode[]\n};\n\nexport type ListItemNode = Range & {\n    _nodeType: CamusNodeType.ListItem,\n    text: CamusLogicLine[],\n}\n\nexport type HorizontalRuleNode = Range & {\n    _nodeType: CamusNodeType.HorizontalRule,\n}\n\n// NOTE: atomic node means an inline node that cannot contain a child node.\nexport type CamusAtomicNode = string | LinkNode | RefNode | FootnoteRefNode | InlineCodeNode | InlineIgnoreNode | ImageNode ;\nexport function isCamusAtomicNode(x: CamusNode): x is CamusAtomicNode {\n    return typeof x === 'string' || [\n        CamusNodeType.Link,\n        CamusNodeType.Ref,\n        CamusNodeType.FootnoteRef,\n        CamusNodeType.InlineCode,\n        CamusNodeType.InlineIgnore,\n        CamusNodeType.Image,\n    ].includes(x._nodeType);\n}\nexport type CamusInlineNode = InlineStyleNode | CamusAtomicNode;\nexport function isCamusInlineNode(x: CamusNode): x is CamusInlineNode {\n    return isCamusAtomicNode(x) || [\n        CamusNodeType.InlineStyle\n    ].includes(x._nodeType);\n}\n// NOTE: `CamusLine` represents a single line of text (not logic line)\nexport type CamusLine = CamusInlineNode[]\nexport type CamusLineNode = FootnoteTextNode | HeadingNode | HorizontalRuleNode;\nexport function isCamusLineNode(x: CamusNode): x is CamusLineNode {\n    return typeof x !== 'string' && [\n        CamusNodeType.FootnoteText,\n        CamusNodeType.Heading,\n        CamusNodeType.HorizontalRule,\n    ].includes(x._nodeType);\n}\nexport type CamusLogicLine = CamusNode[]\nexport type CamusBlockNode = BlockNode | ListNode | FootnoteBlockNode;\nexport function isCamusBlockNode(x: CamusNode): x is CamusBlockNode {\n    return typeof x !== 'string' && [\n        CamusNodeType.Block,\n        CamusNodeType.List,\n        CamusNodeType.FootnoteBlock,\n    ].includes(x._nodeType);\n}\nexport type CamusNode = CamusInlineNode | CamusLineNode | CamusBlockNode;\n","\"use strict\";\n\nexports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {\n    default: a\n  };\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {\n    value: true\n  });\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    } // Skip duplicate re-exports when they have the same value.\n\n\n    if (key in dest && dest[key] === source[key]) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get\n  });\n};","import { ASSERT } from './Assert';\nimport * as ast from './AST';\n\nconst REGEX_BRACE_TAG = /^\\{([a-zA-Z0-9]+)(?:\\(((?:\\\\\\)|[^)])*)\\))?:((?:\\\\\\}|[^}])*)\\}/;\nconst REGEX_FOOTNOTE_TAG = /^\\{footnote@((?:\\\\\\}|\\\\\\]|[^}\\]\\s])*)\\}/;\nconst REGEX_INLINE_CODE = /^`((?:\\\\`|[^`]*))`/;\ntype InlineStyleParseStatus = {\n    bold: boolean,\n    italics: boolean,\n    underline: boolean,\n    delete: boolean,\n}\n\n/*\n\n\nnormal *bold _boldu ~~budelete~~ boldu __ bold*\n\n--> normal              ==> stash=['normal '], stack=[]\n    *                   ==> stash=['normal ',[]], stack=[*]\n    bold                ==> stash=['normal ',['bold']], stack=[*]\n    _                   ==> stash=['normal ',['bold'],[]], stack=[*_]\n    boldu               ==> stash=['normal ',['bold'],['boldu ']], stack=[*_]\n    ~~                  ==> stash=['normal ',['bold'],['boldu '],[]], stack=[*_~~]\n    budelete            ==> stash=['normal ',['bold'],['boldu '],['budelete']], stack=[*_~~]\n    ~~                  ==> stash=['normal ',['bold'],['boldu ',Node(~~,['budelete'])]], stack=[*_]\n     boldu              ==> stash=['normal ',['bold'],['boldu ',Node(~~,['budelete']),' boldu ']], stack=[*_]\n    __                  ==> stash=['normal ',['bold',Node(__,['boldu ',Node(~~,['budelete']),' boldu '])]], stack=[*]\n     bold               ==> stash=['normal ',['bold',Node(__,['boldu ',Node(~~,['budelete']),' boldu ']),'bold']], stack=[*]\n    *                   ==> stash=['normal ',Node(*,['bold',Node(__,['boldu ',Node(~~,['budelete']),' boldu ']),'bold'])], stack=[]\n\n    stash = [], stack = []\n    if x[0] is style char:\n        if x[0] not in stack:\n            push new array in stash.\n            push x[0] in stack.\n        else:\n            z = pop stash top array.\n            new node: stacktop, z.\n            put new node in current stash.\n    else:\n        take until style char.\n        push in stash. \n        continue.\n*/\n// NOTE: requires x to have only one single line.\nexport function _parseInline(x: string): ast.CamusLine {\n    let matchres;\n    let subj = x;\n    let stash: (ast.CamusInlineNode|ast.CamusLine)[] = [];\n    let stack: string[] = [];\n    let _StashPush = (x: string|ast.CamusInlineNode) => {\n        let stashTop = stash[stash.length-1];\n        if (Array.isArray(stashTop)) {\n            stashTop.push(x);\n        } else {\n            stash.push(x);\n        }\n    };\n    while (subj) {\n        if (matchres = REGEX_FOOTNOTE_TAG.exec(subj)) {\n            _StashPush({_nodeType: ast.CamusNodeType.FootnoteRef, id: matchres[1]});\n            subj = subj.substring(matchres[0].length);\n        } else if (matchres = REGEX_BRACE_TAG.exec(subj)) {\n            switch (matchres[1]) {\n                case 'link': {\n                    _StashPush({_nodeType: ast.CamusNodeType.Link, url: matchres[3]||'', text: matchres[2]||''});\n                    break;\n                }\n                case 'img': {\n                    _StashPush({_nodeType: ast.CamusNodeType.Image, url: matchres[3]||'', alt: matchres[2]||''});\n                    break;\n                }\n                case 'ref': {\n                    _StashPush({_nodeType: ast.CamusNodeType.Ref, path: matchres[3]||'' });\n                    break;\n                }\n                default: {\n                    _StashPush(matchres[0]);\n                    break;\n                }\n            }\n            subj = subj.substring(matchres[0].length);\n        } else if (matchres = REGEX_INLINE_CODE.exec(subj)){\n            _StashPush({_nodeType: ast.CamusNodeType.InlineCode, text: matchres[1]});\n            subj = subj.substring(matchres[0].length);\n        } else {\n            if ('*/_'.includes(subj[0]) || subj.startsWith('~~')) {\n                if (stack.includes(subj[0]) || (subj.startsWith('~~') && stack.includes('~~'))) {\n                    // x[0] in stack.\n                    // NOTE: now there's a problem. if we have an input like this:\n                    //     *_bold underline*_\n                    // what should we do about this?\n                    // now (2021.12.6) we decide it should be equivalent with:\n                    //     <b>_bold underline</b>_\n                    // because style character pushes array onto stash, we can restore the original stuff.\n                    // e.g.:\n                    //     *bold _boldu ~~budelete*\n                    // which should be:\n                    //     <b>bold _boldu ~~budelete</b>\n                    // is with a stash and stack of:\n                    //     stash=['normal ',['bold'],['boldu '],['budelete']]\n                    //     stack=[*_~~]\n                    // when the last * is seen. we rewind the stack & it'll be:\n                    //     ['_'] + ['boldu '] + ['~~'] + ['budelete']\n                    // which results in ['_', 'boldu ', '~~', 'budelete']\n                    // so the rewind algorithm:\n                    //     rewindStash = []\n                    //     while stack.top !== subj[0]:\n                    //         rewindStash = stash.pop() + rewindStash\n                    //         rewindStash = [stack.pop()] + rewindStash\n                    //     stashTopArray = stashTopArray + rewindStash\n                    // which will leave stash & stack with:\n                    //     stash=['normal ',['bold','_','boldu ','~~','budelete']]\n                    //     stack=[*]\n                    // which then we follow the normal procedure.\n                    let rewindStash: ast.CamusInlineNode[] = [];\n                    while (\n                        (subj.startsWith('~~') && stack[stack.length-1] !== '~~')\n                        || (!subj.startsWith('~~') && (stack[stack.length-1] !== subj[0]))\n                    ) {\n                        let stashTop = stash.pop()!\n                        rewindStash = [\n                            stack.pop()!,\n                            ...(Array.isArray(stashTop)? stashTop : [stashTop]),\n                            ...rewindStash\n                        ];\n                    }\n                    let stashTop = stash[stash.length-1] as ast.CamusLine;\n                    ASSERT('stashTop should an array.', Array.isArray(stashTop));\n                    stash[stash.length-1] = [...stashTop, ...rewindStash];\n                    // now we resolve stack top:\n                    let styleArray: ('bold'|'italics'|'underline'|'delete')[] = [];\n                    let s = stack.pop();\n                    styleArray.push(\n                        s === '*'? 'bold'\n                        : s === '/'? 'italics'\n                        : s === '_'? 'underline'\n                        : 'delete'\n                    );\n                    let lastStashTop = stash.pop();\n                    let newNode: ast.InlineStyleNode = {_nodeType: ast.CamusNodeType.InlineStyle, style: styleArray, text: lastStashTop as any};\n                    _StashPush(newNode);\n                    subj = subj.substring(subj.startsWith('~~')? 2 : 1);\n                } else {\n                    // x[0] not in stack.\n                    stash.push([]);\n                    stack.push(subj.startsWith('~~')? '~~' : subj[0]);\n                    subj = subj.substring(subj.startsWith('~~')? 2 : 1);\n                }\n            } else if (subj[0] === '\\\\' && subj[1] && '*/_~{`'.includes(subj[1])) {\n                _StashPush(subj[1]);\n                subj = subj.substring(2);\n            } else {\n                let i = 0;\n                while (subj[i] && !'*/_~{`\\\\'.includes(subj[i])) {\n                    i++;\n                }\n                _StashPush(subj.substring(0, i));\n                subj = subj.substring(i);\n            }\n        }\n    }\n    // NOTE: there shouldn't be any inline style left at the end of the line.\n    // if there is, we need to rewind just like above.\n    let rewindStash: ast.CamusInlineNode[] = [];\n    while (stack.length > 0) {\n        let stashTop = stash.pop()!\n        rewindStash = [\n            stack.pop()!,\n            ...(Array.isArray(stashTop)? stashTop : [stashTop]),\n            ...rewindStash\n        ];\n    }\n    // Now there shouldn't be any array in the stash.\n    ASSERT('at the end of finishing rewind stash should not contain array',\n        !rewindStash.map((v) => Array.isArray(v as any)).reduce((a, b) => a || b, false)\n    );\n    stash = stash.concat(rewindStash);\n    ASSERT('at the end of _parseInline stash should be an ast.CamusLine',\n        stash.map((v) => ast.isCamusInlineNode(v as any)).reduce((a, b) => a && b, true)\n    )\n    return stash as ast.CamusLine;\n}\n\n\n// NOTE:\n// 1.  a logic line means:\n//         a.  one line of heading.\n//         b.  one block (the one started with `#{`).\n//         c.  one horizontal rule.\n//         d.  multiple lines of block quote text (started with `>`) with no blank lines\n//             in between.\n//         e.  multiple list item with (1) same bullet (2) same indent (3) no blank lines\n//             in between.\n//         f.  multiple line after a footnote text id with an indent longer than the id\n//             and no blank lines in between, e.g.:\n//                 [1]:blahblahblah\n//                     blahblahblahblha\n//                     blahblablah\n//             and:\n//                 [1]: blahblahblah\n//                          blahblahblahblha\n//                              blahblablah\n//             the 3 lines of blahblahblah belongs to one single logic line, because\n//             they have an indent longer than `[1]:`.\n//         g.  multiple line with no line-level or block-level style and no blank lines\n//             in between.\n// 2.  camus does not support nested block nodes (the one started with `#{`).\n//     if need to input literal text `#}`:\n//         a.  indent the whole content; camus consider the string `#}` *with no indent*\n//             as the end of a block. any indent from the indented content will be removed\n//             accordingly, e.g.:\n//                 #{code javascript\n//                   function hanoi(x, y, z) {\n//                       console.log(\"hello, world!\");\n//                   }\n//                 #}\n//             each line of the block of code inside has the indent of 2 spaces, 6 spaces\n//             and 2 spaces respectively, the shortest indent is 2 space, so 2 spaces of\n//             indent is removed to form the parsing result.\n//         b.  if for any reasons you need to write `#}` with no indent, write `\\#}`.\nconst REGEX_HEADING = /^(={1,6})\\s+(.*)$/;\nconst REGEX_FOOTNOTE_TEXT = /^(\\[((?:\\\\\\}|\\\\\\]|[^}\\]\\s])*)\\]:\\s*)(.*)$/;\nconst REGEX_HORIZONTAL_RULE = /^-{5,}/;\nconst REGEX_QUOTE = /^(>\\s+)(.*)/;\nconst REGEX_BLOCK_START = /^#\\{([^\\s]+)?(?:\\s+(.*))?/;\nconst REGEX_BLOCK_END = /^#\\}/;\nconst REGEX_UNORDERED_LIST_HEAD = /^(([\\+-])(\\s+))(.*)/;\nconst REGEX_ORDERED_LIST_HEAD = /^(([0-9]+)\\.(\\s+))(.*)/;\nconst REGEX_TRIM_LEFT = /^(\\s*)/;\nconst VERBATIM_BLOCK_TYPES = [\n    'verbatim',\n    'code',\n    'ignore',\n]\n\n\nfunction _checkIfSpecialTreatmentRequired(x: string): boolean {\n    return !!(\n        REGEX_HEADING.exec(x)\n        || REGEX_FOOTNOTE_TEXT.exec(x)\n        || REGEX_HORIZONTAL_RULE.exec(x)\n        || REGEX_QUOTE.exec(x)\n        || REGEX_BLOCK_START.exec(x)\n        || REGEX_BLOCK_END.exec(x)\n        || REGEX_UNORDERED_LIST_HEAD.exec(x)\n        || REGEX_ORDERED_LIST_HEAD.exec(x)\n    );\n}\n\nfunction _parseSingleLogicLine(x: string[], n: number): [ast.CamusLogicLine, number]|undefined {\n    if (n >= x.length) { return undefined; }\n    let matchres;\n    if (matchres = REGEX_HEADING.exec(x[n])) {\n        return [\n            [{_nodeType: ast.CamusNodeType.Heading, level: matchres[1].length, text: _parseInline(matchres[2].trim())}],\n            n+1\n        ];\n    } else if (matchres = REGEX_HORIZONTAL_RULE.exec(x[n])) {\n        return [\n            [{_nodeType: ast.CamusNodeType.HorizontalRule}],\n            n+1\n        ];\n    } else if (matchres = REGEX_QUOTE.exec(x[n])) {\n        let i = n+1;\n        let matchres2;\n        let minprefix: string = matchres[1];\n        while ((x[i] !== undefined) && (matchres2 = REGEX_QUOTE.exec(x[i]))) {\n            i++;\n            if (minprefix.length > matchres2[1].length) {\n                minprefix = matchres2[1];\n            }\n        }\n        let subdoc = x.slice(n, i);\n        let subdocRes = _parseDocument(subdoc.map((v) => v.substring(minprefix.length)));\n        return [\n            [{_nodeType: ast.CamusNodeType.Block, type: 'quote', arg: '', text: subdocRes}],\n            i\n        ];\n    } else if (matchres = REGEX_BLOCK_START.exec(x[n])) {\n        let type = matchres[1]?.trim();\n        let args = matchres[2]?.trim();\n        let i = n+1;\n        let matchres2;\n        let subdoc: string[] = [];\n        let minindent: number = +Infinity;\n        while ((x[i] !== undefined) && !(REGEX_BLOCK_END.exec(x[i]))) {\n            matchres2 = REGEX_TRIM_LEFT.exec(x[i]);\n            if (minindent > matchres2![1].length) {\n                minindent = matchres2![1].length;\n            }\n            subdoc.push((x[i] === '\\\\#}')? '#}' : x[i]);\n            i++;\n        }\n        i++;\n        \n        let subdocNoIndent = subdoc.map((v) => v.substring(minindent))\n        let subdocRes: ast.CamusBlockNode =\n            {_nodeType: ast.CamusNodeType.Block,\n                type: type,\n                arg: args,\n                text: VERBATIM_BLOCK_TYPES.includes(type)? subdocNoIndent.map((v) => [v]) : _parseDocument(subdocNoIndent)\n            };\n        return [\n            [subdocRes],\n            i\n        ];\n    } else if (matchres = REGEX_FOOTNOTE_TEXT.exec(x[n])) {\n        let i;\n        let matchres2;\n        let footnoteTextList: ast.FootnoteTextNode[] = [];\n        do {\n            i = n+1;\n            let indent = matchres[1].length;\n            let subdoc: string[] = [x[n].substring(indent).trim()];\n            while ((x[i] !== undefined) && (matchres2 = REGEX_TRIM_LEFT.exec(x[i]))) {\n                if (!x[i] || !x[i].trim() || (matchres2[1].length >= indent)) {\n                    subdoc.push(x[i].substring(indent));\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            let parsedSubdoc = _parseDocument(subdoc);\n            // console.log(parsedSubdoc);\n            let subdocRes: ast.FootnoteTextNode = {\n                _nodeType: ast.CamusNodeType.FootnoteText,\n                id: matchres[2],\n                text: parsedSubdoc\n            };\n            footnoteTextList.push(subdocRes);\n            n = i;\n        } while ((x[n] !== undefined) && (matchres = REGEX_FOOTNOTE_TEXT.exec(x[n])));\n        return [\n            [{_nodeType: ast.CamusNodeType.FootnoteBlock, content: footnoteTextList}],\n            n\n        ];\n    } else if (matchres = REGEX_UNORDERED_LIST_HEAD.exec(x[n])) {\n        let i;\n        let matchres2;\n        let listItemList: ast.ListItemNode[] = [];\n        do {\n            i = n+1;\n            let indent = matchres[1].length;\n            let subdoc: string[] = [x[n].substring(indent).trim()];\n            while ((x[i] !== undefined) && (matchres2 = REGEX_TRIM_LEFT.exec(x[i]))) {\n                if (!x[i] || !x[i].trim() || (matchres2[1].length >= indent)) {\n                    subdoc.push(x[i].substring(indent));\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            let parsedSubdoc = _parseDocument(subdoc);\n            let listItem: ast.ListItemNode = {\n                _nodeType: ast.CamusNodeType.ListItem,\n                text: parsedSubdoc\n            };\n            listItemList.push(listItem);\n            n = i;\n        } while ((x[n] !== undefined) && (matchres = REGEX_UNORDERED_LIST_HEAD.exec(x[n])));\n        return [\n            [{_nodeType: ast.CamusNodeType.List, ordered: false, items: listItemList}],\n            n\n        ];\n    } else if (matchres = REGEX_ORDERED_LIST_HEAD.exec(x[n])) {\n        let i;\n        let matchres2;\n        let listItemList: ast.ListItemNode[] = [];\n        do {\n            i = n+1;\n            let indent = matchres[1].length;\n            let subdoc: string[] = [x[n].substring(indent).trim()];\n            while ((x[i] !== undefined) && (matchres2 = REGEX_TRIM_LEFT.exec(x[i]))) {\n                if (!x[i] || !x[i].trim() || (matchres2[1].length >= indent)) {\n                    subdoc.push(x[i].substring(indent));\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            let parsedSubdoc = _parseDocument(subdoc);\n            let listItem: ast.ListItemNode = {\n                _nodeType: ast.CamusNodeType.ListItem,\n                text: parsedSubdoc\n            };\n            listItemList.push(listItem);\n            n = i;\n        } while ((x[n] !== undefined) && (matchres = REGEX_ORDERED_LIST_HEAD.exec(x[n])));\n        return [\n            [{_nodeType: ast.CamusNodeType.List, ordered: false, items: listItemList}],\n            n\n        ];\n    } else {\n        let i = n;\n        if (x[i] !== undefined) {\n            if (!x[i] || !x[i].trim()) {\n                while ((x[i] !== undefined) && (!x[i] || !x[i].trim())) {\n                    i++;\n                }\n                return [[], i];\n            } else {\n                while (x[i] && x[i].trim() && !_checkIfSpecialTreatmentRequired(x[i])) {\n                    i++;\n                }\n                return [\n                    x.slice(n, i).map((v) => _parseInline(v)).reduce((a, b) => a.concat(b), []),\n                    i\n                ];\n            }\n        }\n    }\n}\n\nfunction _parseDocument(x: string[]): ast.CamusLogicLine[] {\n    let result: ast.CamusLogicLine[] = [];\n    let n = 0;\n    while (x[n] !== undefined) {\n        let parseSingleResult = _parseSingleLogicLine(x, n);\n        if (parseSingleResult) {\n            if (parseSingleResult[0].length > 0) {\n                result.push(parseSingleResult[0]);\n            }\n            n = parseSingleResult[1];\n        } else {\n            result.push(_parseInline(x[n]));\n            n++;\n        }\n    }\n    return result;\n}\n\nexport function parse(x: string): ast.CamusLogicLine[] {\n    return _parseDocument(x.split('\\n'));\n}\n\n","export function ASSERT(text: string, condition: boolean) {\n    if (!condition) {\n        throw new Error(`assert error: ${text}`);\n    }\n}\n","import * as ast from \"./AST\";\nimport { PrettyPrinter } from \"./PrettyPrinter\";\n\nexport type HTMLRendererOption = {\n    additionalHead?: string[],\n    additionalStylesheet?: string[],\n    replacePunctuation?: {\n        singleQuote?: [string, string],\n        doubleQuote?: [string, string],\n        singleDash?: string,\n        doubleDash?: string,        \n    }\n}\n// NOTE: punctuations inside inline code should not be affected.\nexport class CamusHTMLRenderer {\n    private _additionalHead: string[] = [];\n    private _externalStylesheet: string[] = [];\n    private _replacePunctuation: {\n        singleQuote?: [string, string],\n        doubleQuote?: [string, string],\n        singleDash?: string,\n        doubleDash?: string,        \n    }|undefined = undefined;\n    private _pp: PrettyPrinter = new PrettyPrinter();\n    constructor(options?: HTMLRendererOption) {\n        if (options) {\n            this._additionalHead = options.additionalHead || [];\n            this._externalStylesheet = options.additionalStylesheet || [];\n            this._replacePunctuation = options.replacePunctuation;\n        }\n    }\n\n    render(x: ast.CamusLogicLine[]) {\n        this._pp.clear();\n        x.forEach((v) => this._renderLogicLine(v));\n        return this._pp.result;\n    }\n\n    \n    private _singleQuote: boolean = false;\n    private _doubleQuote: boolean = false;\n    _renderLine(x: ast.CamusLine) {\n        this._singleQuote = false;\n        this._doubleQuote = false;\n        x.forEach((v) => this._render(v));\n    }\n    _renderLogicLine(x: ast.CamusLogicLine, noWrapper: boolean = false) {\n        this._singleQuote = false;\n        this._doubleQuote = false;\n        let firstPassed = false;\n        x.forEach((v) => {\n            if (!noWrapper && ast.isCamusInlineNode(v)) {\n                if (!firstPassed) {\n                    this._pp.string('<p>');\n                    firstPassed = true;\n                }\n            } else {\n                if (!noWrapper && firstPassed) {\n                    this._pp.string('</p>').line().indent();\n                    firstPassed = false;\n                }\n            }\n            this._render(v);\n        });\n        if (!noWrapper && firstPassed) {\n            this._pp.string('</p>').line();\n        }\n    }\n    _render(x: ast.CamusNode) {\n        if (typeof x === 'string') {\n            this._text(x);\n        } else {\n            switch (x._nodeType) {\n                case ast.CamusNodeType.Heading: { this._heading(x); break; }\n                case ast.CamusNodeType.Block: { this._block(x); break; }\n                case ast.CamusNodeType.InlineStyle: { this._inlineStyle(x); break; }\n                case ast.CamusNodeType.InlineCode: { this._inlineCode(x); break; }\n                case ast.CamusNodeType.Link: { this._link(x); break; }\n                case ast.CamusNodeType.Ref: { this._ref(x); break; }\n                case ast.CamusNodeType.FootnoteRef: { this._footnoteRef(x); break; }\n                case ast.CamusNodeType.FootnoteText: { this._footnoteText(x); break; }\n                case ast.CamusNodeType.FootnoteBlock: { this._footnoteBlock(x); break; }\n                case ast.CamusNodeType.Image: { this._image(x); break; }\n                case ast.CamusNodeType.List: { this._list(x); break; }\n                case ast.CamusNodeType.InlineIgnore: { break; }\n                case ast.CamusNodeType.HorizontalRule: { this._pp.line().indent().string('<hr />').line(); break; }\n                default: {\n                    this._pp.string(`${x}`);\n                }\n            }\n        }\n    }\n\n    _text(n: string) {\n        if (this._replacePunctuation) {\n            if (!this._replacePunctuation.singleQuote && !this._replacePunctuation.doubleQuote) {\n                this._pp.string(n.replace(/--/g, this._replacePunctuation.doubleDash || '--').replace(/-/g, this._replacePunctuation.singleDash || '-'));\n            } else {\n                let singleQuote: [string, string] = this._replacePunctuation.singleQuote || [\"'\", \"'\"];\n                let doubleQuote: [string, string] = this._replacePunctuation.doubleQuote || ['\"', '\"'];\n                let r: string[] = [];\n                for (let i = 0; i < n.length; i++) {\n                    switch (n[i]) {\n                        case '\"': {\n                            r.push(doubleQuote[this._doubleQuote?1:0]);\n                            this._doubleQuote = !this._doubleQuote;\n                            break;\n                        }\n                        case \"'\": {\n                            r.push(singleQuote[this._singleQuote?1:0]);\n                            this._singleQuote = !this._singleQuote;\n                            break;\n                        }\n                        default: {\n                            r.push(n[i]);\n                            break;\n                        }\n                    }\n                }\n                this._pp.string(r.join(''));\n            }\n        } else {\n            this._pp.string(n);\n        }\n    }\n    _heading(n: ast.HeadingNode) {\n        this._pp.indent().string(`<h${n.level}>`);\n        this._renderLine(n.text);\n        this._pp.string(`</h${n.level}>`).line();\n    }\n    _block(n: ast.BlockNode) {\n        if (n.type === 'ignore') { return; }\n        \n        switch (n.type) {\n            // NOTE: in `verbatim` and `code`, assumes both only contain strings.\n            case 'verbatim': {\n                this._pp.indent().string(`<pre ${n.arg? `class=\"${n.arg}\"` : ''}>`).line().addIndent();\n                n.text.forEach((v) => {\n                    v.forEach((j) => { this._text(j as string); this._pp.line(); });\n                });\n                this._pp.removeIndent().indent().string(`</pre>`).line();\n                break;\n            }\n            case 'code': {\n                this._pp.indent().string(`<pre class=\"code code-${n.arg}\">`).line().addIndent();\n                n.text.forEach((v) => {\n                    v.forEach((j) => { this._text(j as string); this._pp.line(); });\n                });\n                this._pp.removeIndent().indent().string(`</pre>`).line();\n                break;\n            }\n            case 'quote': {\n                this._pp.indent().string(`<blockquote>`).line().addIndent();\n                n.text.forEach((v) => {\n                    this._pp.indent();\n                    v.forEach((j) => { this._render(j); this._pp.line(); });\n                });\n                this._pp.removeIndent().indent().string(`</blockquote>`).line();\n                break;\n            }\n            default: {\n                this._pp.indent().string(`<div class=\"block-${n.arg}\">`).line().addIndent();\n                n.text.forEach((v) => {\n                    this._pp.indent();\n                    v.forEach((j) => { this._render(j); this._pp.line(); });\n                });\n                this._pp.removeIndent().indent().string(`</div>`).line();\n                break;\n            }\n        }\n\n        return;\n    }\n    _inlineStyle(n: ast.InlineStyleNode) {\n        let start = n.style.map((v) => `<${v}>`).join('').replace(/bold/g, 'b').replace(/italics/g, 'i').replace(/underline/g, 'span style=\"text-decoration:underline\"').replace(/delete/g, 'del');\n        let end = n.style.map((v) => `</${v}>`).join('').replace(/bold/g, 'b').replace(/italics/g, 'i').replace(/underline/g, 'span').replace(/delete/g, 'del');\n        this._pp.string(start);\n        this._renderLine(n.text);\n        this._pp.string(end);\n    }\n    _inlineCode(n: ast.InlineCodeNode) {\n        this._pp.string(`<code>${n.text}</code>`);\n    }\n    _link(n: ast.LinkNode) {\n        this._pp.string(`<a href=\"${n.url}\">${n.text||n.url}</a>`);\n    }\n    _ref(n: ast.RefNode) {\n        this._pp.string('');\n    }\n    _footnoteRef(n: ast.FootnoteRefNode) {\n        this._pp.string(`<sup><a href=\"#cite-${n.id}\">[${n.id}]</a></sup>`);\n    }\n    _footnoteText(n: ast.FootnoteTextNode) {\n        this._pp.indent().string(`<div class=\"footnote-item\">[<a name=\"cite-${n.id}\">${n.id}</a>] `);\n        n.text.forEach((v, i) => this._renderLogicLine(v, i === 0));\n        this._pp.removeIndent().indent().string(`</div>`).line();\n    }\n    _footnoteBlock(n: ast.FootnoteBlockNode) {\n        this._pp.indent().string('<div class=\"footnote\">').line().addIndent();\n        n.content.forEach((v) => {\n            this._footnoteText(v);\n        });\n        this._pp.removeIndent().string('</div>').line();\n    }\n    _image(n: ast.ImageNode) {\n        this._pp.string(`<img src=\"${n.url}\" alt=\"${n.alt}\" />`);\n    }\n    _list(n: ast.ListNode) {\n        let tagName = n.ordered? 'ol' : 'ul';\n        this._pp.line().indent().string(`<${tagName}>`).line().addIndent();\n        n.items.forEach((v) => {\n            this._pp.indent().string(`<li>`);\n            v.text.forEach((j) => j.forEach((k) => this._render(k)));\n            this._pp.string(`</li>`).line();\n        });\n        this._pp.removeIndent().indent().string(`</${tagName}>`).line();\n    }\n    preamble() {\n        this._pp.string('<html>').line().addIndent()\n            .indent().string('<head>').line().addIndent();\n        if (this._additionalHead) {\n            this._additionalHead.forEach((v) => {\n                this._pp.indent().string(v).line();\n            });\n        }\n        if (this._externalStylesheet) {\n            this._externalStylesheet.forEach((v) => {\n                this._pp.indent().string(`<link rel=\"stylesheet\" href=\"${encodeURIComponent(v)}\">`).line();\n            });\n        }\n        this._pp.removeIndent().indent().string('</head>').line()\n            .indent().string('<body>').line()\n            .addIndent();\n    }\n    postamble() {\n        this._pp.line().removeIndent().indent().string('</body>').line()\n            .removeIndent().string('</html>').line()\n                .line();\n    }\n}\n\n","export class PrettyPrinter {\n    private _res: string[] = [];\n    private _indent: string = '';\n    addIndent() {\n        this._indent = this._indent + '    ';\n        return this;\n    }\n    removeIndent() {\n        this._indent = this._indent.substring(0, this._indent.length - 4);\n        return this;\n    }\n    indent() {\n        this._res.push(this._indent);\n        return this;\n    }\n    line() {\n        this._res.push('\\n');\n        return this;\n    }\n    string(x: string) {\n        this._res.push(x);\n        return this;\n    }\n    get result() {\n        return this._res.join('');\n    }\n    clear() {\n        this._res = [];\n        this._indent = '';\n    }\n}\n"],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","OVERLAY_ID","OldModule","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","checkedAssets","acceptedAssets","assetsToAccept","location","protocol","indexOf","hostname","port","parent","isParcelRequire","WebSocket","getHostname","getPort","test","ws","onmessage","event","JSON","parse","type","removeErrorOverlay","assets","filter","asset","envHash","handled","forEach","didAccept","hmrAcceptCheck","root","id","depsByBundle","console","clear","hmrApply","i","length","hmrAcceptRun","window","reload","ansiDiagnostic","diagnostics","ansi","stack","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","document","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","map","hint","innerHTML","modules","parents","k","d","dep","Array","isArray","concat","getParents","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","absolute","origin","updateLink","reloadCSS","deps","Function","output","cached","cache","some","v","cb","assetsToAlsoAccept","apply","CamusNodeType","x","Link","Ref","FootnoteRef","InlineCode","InlineIgnore","Image","includes","_nodeType","isCamusAtomicNode","InlineStyle","FootnoteText","Heading","HorizontalRule","Block","List","FootnoteBlock","REGEX_BRACE_TAG","REGEX_FOOTNOTE_TAG","REGEX_INLINE_CODE","matchres","subj","stash","_StashPush","stashTop","exec","substring","url","text","alt","path","startsWith","rewindStash","pop","styleArray","s","lastStashTop","newNode","style","reduce","a","b","isCamusInlineNode","REGEX_HEADING","REGEX_FOOTNOTE_TEXT","REGEX_HORIZONTAL_RULE","REGEX_QUOTE","REGEX_BLOCK_START","REGEX_BLOCK_END","REGEX_UNORDERED_LIST_HEAD","REGEX_ORDERED_LIST_HEAD","REGEX_TRIM_LEFT","VERBATIM_BLOCK_TYPES","n","level","_parseInline","trim","matchres2","minprefix","subdoc","slice","subdocRes","_parseDocument","arg","args","minindent","Infinity","subdocNoIndent","footnoteTextList","indent","parsedSubdoc","content","listItemList","listItem","ListItem","ordered","items","_checkIfSpecialTreatmentRequired","result","parseSingleResult","_parseSingleLogicLine","condition","Error","_additionalHead","_externalStylesheet","_replacePunctuation","_pp","constructor","options","additionalHead","additionalStylesheet","replacePunctuation","render","_renderLogicLine","_singleQuote","_doubleQuote","_renderLine","_render","noWrapper","firstPassed","string","line","_text","_heading","_block","_inlineStyle","_inlineCode","_link","_ref","_footnoteRef","_footnoteText","_footnoteBlock","_image","_list","singleQuote","doubleQuote","replace","doubleDash","singleDash","r","addIndent","j","removeIndent","start","end","tagName","preamble","encodeURIComponent","postamble","_res","_indent"],"version":3,"file":"index.e7656e88.js.map","sourceRoot":"/__parcel_source_root/"}